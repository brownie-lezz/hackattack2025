from fastapi import APIRouter, HTTPException
from typing import List, Optional
from pydantic import BaseModel

router = APIRouter(prefix="/api/jobs", tags=["jobs"])

# Try to import ML service
try:
    from ml_model.salary_service import prediction_service
except ImportError as e:
    # If prediction_service is critical and fails to import, 
    # the app might not work correctly or main.py's error handling for blueprint registration will catch it.
    # For now, allow it to proceed; calls to a potentially None prediction_service will error at runtime.
    prediction_service = None # Explicitly set to None if import fails, to be checked before use if necessary

@router.post("/salary-prediction")
async def predict_salary(data: dict):
    """
    API endpoint for salary prediction
    """
    if not prediction_service:
        raise HTTPException(status_code=503, detail="Prediction service is not available")
        
    try:
        # Format the request data for the ML model
        ml_request_data = {
            "title": data.get('title', ''),
            "location": data.get('location', 'Remote'),
            "formatted_work_type": data.get('workType', 'Full-time'),
            "formatted_experience_level": data.get('experienceLevel', 'Entry level'),
            "company_industries": data.get('industry', 'Technology'),
            "skill_requirement": ', '.join(data.get('skills', [])),
            "education_requirement": data.get('education', ''),
            "certification_requirement": data.get('certification', ''),
            "experience_requirement": data.get('experience', ''),
            "remote_allowed": data.get('remote', False),
            "company_employee_count": data.get('companySize', 500),
            "as_monthly": data.get('as_monthly', True)
        }
        
        # Get prediction from the service
        result = prediction_service.predict(ml_request_data)
        
        if not result.get("success", False):
            raise HTTPException(status_code=500, detail="Service reported an error")
            
        return result
            
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/similar-jobs")
async def get_similar_jobs(data: dict):
    """
    API endpoint for similar jobs
    """
    if not prediction_service:
        raise HTTPException(status_code=503, detail="Prediction service is not available")
        
    try:
        # Prepare request data
        request_data = {
            "title": data.get('title', ''),
            "location": data.get('location', 'Remote'),
            "skills": data.get('keywords', '').split(', ') if isinstance(data.get('keywords'), str) else [],
            "type": data.get('workType', 'Full-time')
        }
        
        # Get similar jobs from the service
        similar_jobs = prediction_service.get_similar_jobs(request_data)
        return similar_jobs
            
    except RuntimeError as e:
        # Handle errors specifically from the get_similar_jobs service call
        raise HTTPException(status_code=503, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/create")
async def create_job(job_data: dict):
    """
    API endpoint for job creation
    """
    try:
        # Here you would typically save the job to a database
        # For now, we'll just return the job data with a mock ID
        job_data['id'] = '12345'  # In production, this would be generated by the database
        
        return {
            "success": True,
            "message": "Job created successfully",
            "job": job_data
        }
            
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e)) 